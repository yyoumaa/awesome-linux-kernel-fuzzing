# awesome-linux-kernel-fuzzing
This repository aims to provide a curated list of research papers（from 2019） focusing on linux kernel fuzzing. Papers without *fuzz* and *kernel* keywords in the title may be missed.

--------------------------------------------------------------------------------------------------------------------------
### [S&P'19] Razzer: Finding Kernel Race Bugs through Fuzzing

[[paper]](https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=8835326)
<details>
  <summary>Click to see the abstract!</summary>
A data race in a kernel is an important class of bugs,  critically impacting the reliability and security of the associated  system.  As a result of a race, the kernel may become unresponsive.  Even worse, an attacker may launch a privilege escalation attack  to acquire root privileges.  In this paper, we propose RAZZER, a tool to find race bugs  in kernels.  The core of RAZZER is in guiding fuzz testing  towards potential data race spots in the kernel.  RAZZER employs  two techniques to find races efficiently: a static analysis and  a deterministic thread interleaving technique.  Using a static  analysis, RAZZER identifies over-approximated potential data  race spots, guiding the fuzzer to search for data races in the  kernel more efficiently.  Using the deterministic thread interleaving technique implemented at the hypervisor, RAZZER tames  the non-deterministic behavior of the kernel such that it can  deterministically trigger a race.  We implemented a prototype of RAZZER and ran the latest Linux kernel (from v4.16-rc3 to v4.18-  rc3) using RAZZER.  As a result, RAZZER discovered 30 new races  in the kernel, with 16 subsequently confirmed and accordingly  patched by kernel developers after they were reported.
</details>

### [USENIX'20] Agamotto: Accelerating Kernel Driver Fuzzing with Lightweight Virtual Machine Checkpoints

[[paper]](https://www.usenix.org/system/files/sec20-song.pdf)
<details>
  <summary>Click to see the abstract!</summary>
Kernel-mode drivers are challenging to analyze for vulnerabilities, yet play a critical role in maintaining the security  of OS kernels. Their wide attack surface, exposed via both  the system call interface and the peripheral interface, is often  found to be the most direct attack vector to compromise an OS  kernel. Researchers therefore have proposed many fuzzing  techniques to find vulnerabilities in kernel drivers. However,  the performance of kernel fuzzers is still lacking, for reasons  such as prolonged execution of kernel code, interference between test inputs, and kernel crashes. This paper proposes lightweight virtual machine checkpointing as a new primitive that enables high-throughput  kernel driver fuzzing. Our key insight is that kernel driver  fuzzers frequently execute similar test cases in a row, and that  their performance can be improved by dynamically creating  multiple checkpoints while executing test cases and skipping  parts of test cases using the created checkpoints. We built a  system, dubbed Agamotto, around the virtual machine checkpointing primitive and evaluated it by fuzzing the peripheral  attack surface of USB and PCI drivers in Linux. The results  are convincing. Agamotto improved the performance of the  state-of-the-art kernel fuzzer, Syzkaller, by 66.6% on average in fuzzing 8 USB drivers, and an AFL-based PCI fuzzer  by 21.6% in fuzzing 4 PCI drivers, without modifying their  underlying input generation algorithm.
</details>

### [S&P'20] Krace: Data Race Fuzzing for Kernel File Systems

[[paper]](https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=9152693)
<details>
  <summary>Click to see the abstract!</summary>
Data races occur when two threads fail to use  proper synchronization when accessing shared data.  In kernel file  systems, which are highly concurrent by design, data races are  common mistakes and often wreak havoc on the users, causing  inconsistent states or data losses.  Prior fuzzing practices on file  systems have been effective in uncovering hundreds of bugs, but  they mostly focus on the sequential aspect of file system execution  and do not comprehensively explore the concurrency dimension  and hence, forgo the opportunity to catch data races.  In this paper, we bring coverage-guided fuzzing to the concurrency dimension with three new constructs: 1) a new coverage  tracking metric, alias coverage, specially designed to capture  the exploration progress in the concurrency dimension;  2) an  evolution algorithm for generating, mutating, and merging multithreaded syscall sequences as inputs for concurrency fuzzing;   and 3) a comprehensive lockset and happens-before modeling for  kernel synchronization primitives for precise data race detection.  These components are integrated into KRACE, an end-to-end  fuzzing framework that has discovered 23 data races in ext4,  btrfs, and the VFS layer so far, and 9 are confirmed to be harmful.
</details>

### [NDSS'20] HFL: Hybrid Fuzzing on the Linux Kernel

[[paper]](https://www.ndss-symposium.org/wp-content/uploads/2020/02/24018-paper.pdf)
<details>
  <summary>Click to see the abstract!</summary>
Hybrid fuzzing, combining symbolic execution and  fuzzing, is a promising approach for vulnerability discovery  because each approach can complement the other.  However,  we observe that applying hybrid fuzzing to kernel testing is  challenging because the following unique characteristics of the  kernel make a naive adoption of hybrid fuzzing inefficient: 1) having indirect control transfers determined by system call  arguments, 2) controlling and matching internal system state via  system calls, and 3) inferring nested argument type for invoking  system calls.  Failure to handling such challenges will render both  fuzzing and symbolic execution inefficient, and thereby, will result  in an inefficient hybrid fuzzing.  Although these challenges are  essential to both fuzzing and symbolic execution, to the best of  our knowledge, existing kernel testing approaches either naively  use each technique separately without handling such challenges  or imprecisely handle a part of challenges only by static analysis.  To this end, this paper proposes HFL, which not only  combines fuzzing with symbolic execution for hybrid fuzzing  but also addresses kernel-specific fuzzing challenges via three  distinct features: 1) converting indirect control transfers to direct  transfers, 2) inferring system call sequence to build a consistent  system state, and 3) identifying nested arguments types of system  calls.  As a result, HFL found 24 previously unknown vulnerabilities in recent Linux kernels.  Additionally, HFL achieves 15%  and 26% higher code coverage than Moonshine and Syzkaller,  respectively, and over kAFL/S2E/TriforceAFL, achieving even  four times better coverage, using the same amount of resources (CPU, time, etc.).  Regarding vulnerability discovery performance, HFL found 13 known vulnerabilities more than three times faster  than Syzkaller.
</details>

### [S&P'21] [Windows] NtFuzz: Enabling Type-Aware Kernel Fuzzing on Windows with Static Binary Analysis

[[paper]](https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=9519448)
<details>
  <summary>Click to see the abstract!</summary>
Although it is common practice for kernel fuzzers to leverage type information of system calls, current Windows kernel fuzzers do not follow the practice as most system calls are private and largely undocumented.  In this paper, we present a practical static binary analyzer that automatically infers system call types on Windows at scale.  We incorporate our analyzer to NtFuzz, a type-aware Windows kernel fuzzing framework.  To our knowledge, this is the first practical fuzzing system that utilizes scalable binary analysis on a COTS OS.  With NtFuzz, we found 11 previously unknown kernel bugs, and earned $25,000 through the bug bounty program offered by Microsoft.  All these results confirm the practicality of our system as a kernel fuzzer.
</details>

### [USENIX'21] SyzVegas: Beating Kernel Fuzzing Odds with Reinforcement Learning

[[paper]](https://www.usenix.org/system/files/sec21-wang-daimeng.pdf)
<details>
  <summary>Click to see the abstract!</summary>
Fuzzing embeds a large number of decisions requiring finetuned and hard-coded parameters to maximize its efficiency. This is especially true for kernel fuzzing due to (1) OS kernels’ sheer size and complexity, (2) a unique syscall interface  that requires special handling (e.g., encoding explicit dependencies among syscalls), and (3) behaviors of inputs (i.e., test  cases) are often not reproducible due to the stateful nature of OS kernels. Hence, Syzkaller [14], the state-of-art gray-box  kernel fuzzer, incorporates numerous procedures, decision  points, and hard-coded parameters master-crafted by domain  experts. Unfortunately, hard-coded strategies cannot adjust  to factors such as different fuzzing environments/targets and  the dynamically changing potency of tasks and/or seeds, limiting the overall effectiveness of the fuzzer. In this paper,  we propose SYZVEGAS, a fuzzer that dynamically and automatically adapts two of the most critical decision points  in Syzkaller, task selection and seed selection, to remarkably  improve coverage reached per unit-time. SYZVEGAS’s adaptation leverages multi-armed-bandit (MAB) algorithms along  with a novel reward assessment model. Our extensive evaluations of SYZVEGAS on the latest Linux Kernel and its subsystems demonstrate that it (i) finds up to 38.7% more coverage  than the default Syzkaller, (ii) better discovers bugs/crashes (8 more unique crashes) and (iii) has very low 2.1% performance overhead. We reported our findings to Google’s Syzkaller team and are actively working on pushing our  changes upstream.
</details>

### [USENIX'22] SyzScope: Revealing High-Risk Security Impacts of Fuzzer-Exposed Bugs in Linux kernel

[[paper]](https://www.usenix.org/system/files/sec22-zou.pdf)
<details>
  <summary>Click to see the abstract!</summary>
Fuzzing has become one of the most effective bug finding approach for software. In recent years, 24*7 continuous fuzzing platforms have emerged to test critical  pieces of software, e.g., Linux kernel. Though capable of  discovering many bugs and providing reproducers (e.g.,  proof-of-concepts), a major problem is that they neglect a  critical function that should have been built-in, i.e., evaluation of a bug’s security impact. It is well-known that  the lack of understanding of security impact can lead to  delayed bug fixes as well as patch propagation. In this  paper, we develop SyzScope, a system that can automatically uncover new “high-risk” impacts given a bug  with seemingly “low-risk” impacts. From analyzing over  a thousand low-risk bugs on syzbot, SyzScope successfully determined that 183 low-risk bugs (more than 15%)  in fact contain high-risk impacts, e.g., control flow hijack  and arbitrary memory write, some of which still do not  have patches available yet.
</details>

### [S&P'23] SegFuzz: Segmentizing Thread Interleaving to Discover Kernel Concurrency Bugs through Fuzzing

[[paper]](https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=10179398)
<details>
  <summary>Click to see the abstract!</summary>
Discovering kernel concurrency bugs through fuzzing is challenging. Identifying kernel concurrency bugs, as opposed to non-concurrency bugs, necessitates an analysis of possible interleavings between two or more threads. However, because the search space of thread interleaving is vast, it is impractical to investigate all conceivable thread interleavings. To explore the vast search space, most previous approaches perform random or simple heuristic searches without having coverage for thread interleaving or with an insufficient form of coverage. As a result, they either conduct wasteful searches with redundant executions or overlook concurrent bugs that their coverage cannot address.To overcome such limitations, we propose SegFuzz, a fuzzing framework for kernel concurrency bugs. When exploring the search space of thread interleavings, SegFuzz decomposes an entire thread interleaving into a set of segments, each of which represents an interleaving of the small number of instructions, and utilizes individual segments as interleaving coverage, called interleaving segment coverage. When searching for thread interleavings, SegFuzz mutates interleavings in explored interleaving segments to construct new thread interleavings that have not yet been explored. With SegFuzz, we discover new 21 concurrency bugs in Linux kernels, and demonstrate the efficiency of SegFuzz by showing that SegFuzz can identify known bugs on average 4.1 times quickly than the state-of-the-art approaches.
</details>

### [CCS'23] SyzDirect: Directed Greybox Fuzzing for Linux Kernel

[[paper]](https://dl.acm.org/doi/pdf/10.1145/3576915.3623146)
<details>
  <summary>Click to see the abstract!</summary>
Bug reports and patch commits are dramatically increasing for OS kernels, incentivizing a critical need for kernel-level bug  reproduction and patch testing.  Directed greybox fuzzing (DGF),  aiming to stress-test a specific part of code, is a promising approach  for bug reproduction and patch testing.  However, the existing DGF methods exclusively target user-space applications, presenting  intrinsic limitations in handling OS kernels.  In particular, these  methods cannot pinpoint the appropriate system calls and the  needed syscall parameter values to reach the target location,  resulting in low efficiency and waste of resources.  In this paper, we present SyzDirect, a DGF solution for the Linux kernel.  With a novel, scalable static analysis of the Linux  kernel, SyzDirect identifies valuable information such as correct  system calls and conditions on their arguments to reach the target  location.  During fuzzing, SyzDirect utilizes the static analysis  results to guide the generation and mutation of test cases, followed  by leveraging distance-based feedback for seed prioritization and  power scheduling.  We evaluated SyzDirect on upstream Linux  kernels for bug reproduction and patch testing.  The results show  that SyzDirect can reproduce 320% more bugs and reach 25.6%  more target patches than generic kernel fuzzers.  It also improves  the speed of bug reproduction and patch reaching by a factor of 154.3 and 680.9, respectively.
</details>

### [USENIX'23] BoKASAN: Binary-only Kernel Address Sanitizer for Effective Kernel Fuzzing

[[paper]](https://www.usenix.org/system/files/usenixsecurity23-cho.pdf)
<details>
  <summary>Click to see the abstract!</summary>
Fuzzing has become one of the most effective bug finding approach for software. In recent years, 24*7 continuous fuzzing platforms have emerged to test critical  pieces of software, e.g., Linux kernel. Though Kernel Address Sanitizer (KASAN), an invaluable tool for  finding use-after-free and out-of-bounds bugs in the Linux  kernel, needs the kernel source for compile-time instrumentation. To apply KASAN to closed-source systems, we should  develop a binary-only KASAN, which is challenging. A technique that uses binary rewriting and processor support to run KASAN for binary modules needs a KASAN-applied kernel, thereby still the kernel source. Dynamic instrumentation  offers an alternative way to it but greatly increases the performance overhead, rendering the kernel fuzzing impractical. To address these problems, we present the first practical,  binary-only KASAN named BoKASAN, which conducts address sanitization through dynamic instrumentation for the  entire kernel binaries efficiently. Our key idea is selective  sanitization, which identifies target processes to sanitize and  hooks the page fault mechanism for significantly reducing the  performance overhead of dynamic instrumentation. Our key  insight is that the kernel bugs are most relevant to the processes created by a fuzzer. Thus, BoKASAN deliberately sanitizes the target memory regions related to these processes and  leaves the remains unsanitized for effective kernel fuzzing. Our evaluation results show that BoKASAN is practical  on closed-source systems, achieving the compiler-level performance of KASAN even on binary-only kernels and modules. Compared to KASAN on the Linux kernel, BoKASAN  detected slightly more bugs in the Janus dataset and slightly  fewer bugs in the Syzkaller/SyzVegas dataset; and BoKASAN  found the same number of unique bugs in the 5-day fuzzing  and executed the similar number of basic blocks. For binary  modules on the Windows kernel and the Linux kernel, resp., BoKASAN was effective in finding bugs. An ablation result  shows that selective sanitization affected these outcomes.
</details>

### [USENIX'23] ACTOR: Action-Guided Kernel Fuzzing

[[paper]](https://www.usenix.org/system/files/usenixsecurity23-fleischer.pdf)
<details>
  <summary>Click to see the abstract!</summary>
Fuzzing reliably and efficiently finds bugs in software,  including operating system kernels. In general, higher code  coverage leads to the discovery of more bugs. This is why most  existing kernel fuzzers adopt strategies to generate a series of  inputs that attempt to greedily maximize the amount of code  that they exercise. However, simply executing code may not  be sufficient to reveal bugs that require specific sequences of  actions. Synthesizing inputs to trigger such bugs depends on  two aspects: (i) the actionsthe executed code takes, and (ii) the  order in which those actions are taken. An action is a high-level  operation, such as a heap allocation, that is performed by the  executed code and has a specific semantic meaning. ACTOR, our action-guided kernel fuzzing framework,  deviates from traditional methods. Instead of focusing on  code coverage optimization, our approach generates fuzzer  programs (inputs) that leverage our understanding of triggered  actions and their temporal relationships. Specifically, we  first capture actions that potentially operate on shared data  structures at different times. Then, we synthesize programs  using those actions as building blocks, guided by bug  templates expressed in our domain-specific language. We evaluated ACTOR on four different versions of the Linux  kernel, including two well-tested and frequently updated  long-term (5.4.206, 5.10.131) versions, a stable (5.19), and  the latest (6.2-rc5) release. Our evaluation revealed a total of 41 previously unknown bugs, of which 9 have already been  fixed. Interestingly, 15 (36.59%) of them were discovered in  less than a day.
</details>

### [USENIX'23] [macOS]KextFuzz: Fuzzing macOS Kernel EXTensions on Apple Silicon via Exploiting Mitigations

[[paper]](https://www.usenix.org/system/files/usenixsecurity23-yin.pdf)
<details>
  <summary>Click to see the abstract!</summary>
macOS drivers, i.e., Kernel EXTensions (kext), are attractive attack targets for adversaries. However, automatically  discovering vulnerabilities in kexts is extremely challenging  because kexts are mostly closed-source, and the latest macOS  running on customized Apple Silicon has limited tool-chain  support. Most existing static analysis and dynamic testing  solutions cannot be applied to the latest macOS. In this paper,  we present the first smart fuzzing solution KextFuzz to detect  bugs in the latest macOS kexts running on Apple Silicon. Unlike existing driver fuzzing solutions, KextFuzz does not  require source code, execution traces, hypervisors, or hardware features (e.g., coverage tracing) and thus is universal  and practical. We note that macOS has deployed many mitigations, including pointer authentication, code signature, and  userspace kernel layer wrappers, to thwart potential attacks. These mitigations can provide extra knowledge and resources  for us to enable kernel fuzzing. KextFuzz exploits these mitigation schemes to instrument the binary for coverage tracking,  test privileged kext code that is guarded and infrequently accessed, and infer the type and semantic information of the  kext interfaces. KextFuzz has found 48 unique kernel bugs in  the macOS kexts and got five CVEs. Some bugs could cause  severe consequences like non-recoverable denial-of-service  or damages.
</details>

### [NDSS'23] No Grammar, No Problem: Towards Fuzzing the Linux Kernel without System-Call Descriptions.

[[paper]](https://www.ndss-symposium.org/wp-content/uploads/2023/02/ndss2023_f688_paper.pdf)
<details>
  <summary>Click to see the abstract!</summary>
The integrity of the entire computing ecosystem  depends on the security of our operating systems (OSes).  Unfortunately, due to the scale and complexity of OS code, hundreds  of security issues are found in OSes, every year [32].  As such,  operating systems have constantly been prime use-cases for  applying security-analysis tools.  In recent years, fuzz-testing has  appeared as the dominant technique for automatically finding  security issues in software.  As such, fuzzing has been adapted  to find thousands of bugs in kernels [14].  However, modern OS  fuzzers, such as Syzkaller, rely on precise, extensive, manuallycreated harnesses and grammars for each interface fuzzed within  the kernel.  Due to this reliance on grammars, current OS fuzzers  are faced with scaling-issues.  In this paper, we present FUZZNG, our generic approach to  fuzzing system-calls on OSes.  Unlike Syzkaller, FUZZNG does not  require intricate descriptions of system-call interfaces in order to  function.  Instead FUZZNG leverages fundamental kernel design  features in order to reshape and simplify the fuzzer’s input-space.  As such FUZZNG only requires a small config, for each new  target: essentially a list of files and system-call numbers the fuzzer  should explore.  We implemented FUZZNG for the Linux kernel.  Testing FUZZNG over 10 Linux components with extensive descriptions in Syzkaller showed that, on average, FUZZNG achieves 102.5% of Syzkaller’s coverage.  FUZZNG found 9 new bugs (5 in components that Syzkaller had already fuzzed extensively,  for years).  Additionally, FUZZNG’s lightweight configs are less  than 1.7% the size of Syzkaller’s manually-written grammars. Crucially, FUZZNG achieves this without initial seed-inputs, or  expert guidance.
</details>

### [S&P'24] SyzGen++: Dependency Inference for Augmenting Kernel Driver Fuzzing

[[paper]](https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=10646807)
<details>
  <summary>Click to see the abstract!</summary>
In recent years, kernel fuzzing research has experienced a significant surge. Among various kernel fuzzers, Syzkaller stands out as the state-of-the-art tool, having identified over 5,000 bugs in the Linux kernel. Syzkaller’s success can be attributed to its utilization of manually-curated  syscall specifications provided by kernel experts. However, this  process is time-consuming and not scalable due to complex  input structures and unknown dependencies among syscalls. Consequently, a substantial portion of the kernel codebase,  specifically kernel drivers, lacks specifications, posing a significant security risk. In this paper, we introduce SyzGen++, an innovative  approach for automatically inferring dependencies between  syscalls and generating specifications without relying on existing test suites. Specifically, we define two fundamental building  blocks of insertion and lookup operations and their pairing  to accurately identify dependencies. We evaluated SyzGen++  against existing state-of-the-art techniques on both Linux  and macOS drivers. Our results demonstrate that SyzGen++  uncovered 245 more dependencies. Furthermore, SyzGen++  outperforms DIFUZE, KSG, and SyzDescribe in terms of code  coverage, achieving 71%, 67%, and 39% improvement on  average, respectively. Notably, our evaluation discovered 10  previously unknown bugs in Linux Kernel 6.2 using specifications generated by SyzGen++, resulting in 6 CVEs, which  demonstrates its effectiveness in identifying vulnerabilities.
</details>
